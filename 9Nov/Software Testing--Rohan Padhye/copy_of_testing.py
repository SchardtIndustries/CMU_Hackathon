# -*- coding: utf-8 -*-
"""Copy of Testing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d9A6a5-2_uu2BKNRQEwh8PZk_kkSGPAS

# Unit Testing

Let's revisit some functions seen in previous modules and considering how they can be tested.

Unit testing involves executing a single function with one or more inputs and checking that the outputs it produces match our expectations. These checks are called *assertions*. The statement `assert(<predicate>)` will do nothing if the `<predicate>` expression evaluates to `True`, but it will raise an error if the predicate evaluates to `False`.
"""

def isPrime(n):
    if n < 2:
        return False
    for factor in range(2, n):
        if n % factor == 0:
            return False
    return True

def testIsPrime():
    print('Testing isPrime()... ', end='')
    assert(isPrime(2) == True)
    assert(isPrime(7) == True)
    assert(isPrime(8) == False)
    assert(isPrime(9) == False)
    assert(isPrime(11) == True)
    print('Passed!')

testIsPrime()

"""## Exercise:

Write unit tests for the `quicksort` function seen earlier.
"""

def quicksort(L):
    if (len(L) < 2):
        return L
    else:
        first = L[0]  # pivot
        rest = L[1:]
        lo = [x for x in rest if x < first]
        hi = [x for x in rest if x >= first]
        solution = quicksort(lo) + [first] + quicksort(hi)
        return solution

def testQuicksort():
    print('Testing quicksort()... ', end='')

    assert(quicksort([1, 2, 3, 4]) == ([1, 2, 3, 4]))
    assert(quicksort([9, 8, 7, 6, 5]) == ([5, 6, 7, 8, 9]))
    assert(quicksort([1, 9, 2, 8]) ==([1, 2, 8, 9]))
    try:
       quicksort([1, 2, 3, "r"])
    except:
      assert(True)  # error seen
    else:
      assert(False) # error not seen

    print('Passed!')

testQuicksort()

"""# Coverage

Code coverage helps you measure how much of your code is being exercised by the tests that you have written/executed. Coverage helps identify obvious gaps in testing, since you cannot find a bug on line X if you don't have a test that executes line X.
"""

def isPrime(n):
    if n < 2:
        return False
    for factor in range(2, n):
        if n % factor == 0:
            return False
    return True

def testIsPrime():
    print('Testing isPrime()... ', end='')
    assert(isPrime(2) == True)
    assert(isPrime(7) == True)
    assert(isPrime(8) == False)
    assert(isPrime(9) == False)
    assert(isPrime(11) == True)
    print('Passed!')

# testIsPrime()

# Install the coverage module (do this just once)
# !pip install -q coverage

# Run a code coverage tool with branch coverage
# !coverage run --branch primes.py

# Get a coverage report with missing lines (-m)
# !coverage report -m

"""# Bonus 1: Property-Based Testing

Instead of picking specific test cases (i.e., inputs) to test our functions with, we can pick inputs at random and check that the corresponding outputs satisfy a property. This is a powerful technique but requires a bit of thinking as to what properties a function should satify, and how to cleverly generate inputs for which we can check these properties.
"""

import random

def isPrime(n):
    if n < 2:
        return False
    for factor in range(2, n):
        if n % factor == 0:
            return False
    return True

def testProductsCannotBePrime(trials):
  for trial in range(trials):
    a = random.randint(2, 100)
    b = random.randint(2, 100)
    product = a * b
    print(f"Verifying that {product} = {a} x {b} is not prime... ", end='')
    assert(isPrime(product) == False)
    print("Yep!")

testProductsCannotBePrime(20)

"""## Exercise

Write some better properties for quicksort.
"""

import random

def quicksort(L):
    if (len(L) < 2):
        return L
    else:
        first = L[0]  # pivot
        rest = L[1:]
        lo = [x for x in rest if x < first]
        hi = [x for x in rest if x >= first]
        return quicksort(lo) + [first] + quicksort(hi)

def testQuicksortProducesSortedList(trials):
  for trial in range(trials):
    length = random.randint(0, 10) # A list of up to 10 elements
    input = [random.randint(-100, 100) for i in range(length)]
    output = quicksort(input)
    print(f"Verifying that {input} is sorted... ", end='')

    # Check that the output is indeed sorted
    for i in range(1, len(output)):
      assert(output[i-1] <= output[i]) # Change this

    print("Yep!")

testQuicksortProducesSortedList(20)

"""# Bonus 2: Differential Testing

When you have multiple implementations of the same functionality, you can perform a powerful type of property-based testing where the property is available for free: for random inputs, you can check whether both of the implementations produce the same output. If the two implementations disagree on any given input, then at least one of them must have a bug.

Such *differential testing* is a powerful technique for testing code that you are optimizing (e.g., to compare the unoptimized and optimized versions of the code) or when you are implementing functionality that is specified in a standard that is meant to be interoperable across programs (e.g., parsing files in standard formats such as XML or JSON, or conforming to a communication protocol such as TLS or 5G).

Let's demonstrate this by testing the slow version of `isPrime` with the optimized equivalent `fasterIsPrime`.
"""

import random

def isPrime(n):
    if n < 2:
        return False
    for factor in range(2, n):
        if n % factor == 0:
            return False
    return True

def fasterIsPrime(n):
    if n < 2:
        return False
    elif n == 2:
        return True
    elif n % 2 == 0:
        return False
    maxFactor = round(n**0.5)
    for factor in range(3, maxFactor + 1, 2):
        if n % factor == 0:
            return False
    return True

def compareFastAndSlowPrimes(trials):
  for trial in range(trials):
    x = random.randint(0, 10000)
    print(f"Verifying that both algorithms agree on isPrime({x})... ", end='')
    assert(isPrime(x) == fasterIsPrime(x))
    print("Yep!")

compareFastAndSlowPrimes(20)

"""## Exercise

Perform a differential test for `quickSort` by comparing it with the in-built `sorted` function.
"""

import random

def quicksort(L):
    if (len(L) < 2):
        return L
    else:
        first = L[0]  # pivot
        rest = L[1:]
        lo = [x for x in rest if x < first]
        hi = [x for x in rest if x >= first]
        return quicksort(lo) + [first] + quicksort(hi)

def compareQuicksortAndSorted(trials):
  for trial in range(trials):
    length = random.randint(0, 10) # A list of up to 10 elements
    input = [random.randint(-100, 100) for i in range(length)]
    print(f"Verifying that quicksort({input}) agrees with sorted()... ", end='')

    # Check that the result of quicksort() and sorted() is equal
    assert(quicksort(input) == sorted(input)) # Change this

    print("Yep!")

compareQuicksortAndSorted(20)